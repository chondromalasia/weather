import sys

import pandas as pd

import src.utils as utils
import src.database as db

def process_forecasts_and_observations(df):
    """Pandas dataframe with columns:
    City, forecast_date, Platform, forecast_temperature,
    observed_date, observed_temperature

    make sure they are the correct type and create an error column.

    error = observed - forecast"""

    df = df.copy()
    df = df.dropna(subset=['observed_temperature', "forecast_temperature"])
    df["observed_temperature"] = df["observed_temperature"].astype(int)
    df["forecast_temperature"] = df["forecast_temperature"].astype(int)
    df["error"] = df["observed_temperature"] -  df["forecast_temperature"] 

    return df

def list_to_dataframe(forecast_list):
    """Convert the list created from scraper into a dataframe"""
    
    df = pd.DataFrame(forecast_list, columns=["CITY",
                                              "FORECAST_DATE",
                                              "TIME_OF_FORECAST",
                                              "PLATFORM",
                                              "TEMPERATURE"])
    df["ID"] = None
    df = df[["ID", "CITY", "FORECAST_DATE", "TIME_OF_FORECAST", "PLATFORM", "TEMPERATURE"]]
    df["TEMPERATURE"] = df["TEMPERATURE"].astype(int)
    return df

def key_gen(city, operator, threshold):
    """Create a unique string for each set of odds that was made."""
    
    return f"{city} - {operator} - {threshold}"

def city_platform(df, city, platform):
    """Get all of the forecasts for a given city and platform
    ex. return all rows for 'CHI' and 'TWC'"""
    
    df = df.copy()
    mask = (df["CITY"] == city) & (df["PLATFORM"] == platform)
    
    return df[mask]

def trim_errors(df, error, operator):
    """Given a data frame, a given error and an operator, return a filtered
    dataframe outside of the errors
    ex. df, -1, 'lt=' <- in this case you would return all rows that had
    an error less than one."""
    
    df = df.copy()

    if operator == "lt=":
        df = df[df["error"] <= error]
    elif operator == "gt=":
        df = df[df["error"] >= error]
    elif operator == "bw":
        mask = (df["error"] >= error[0]) & (df["error"] <= error[1])
        df = df[mask]
        
    return df

def errors_by_platform(df, city, platform, forecast, threshold, operator):
    """For a given city and forecast platform, get a dataframe which has
    errors within the appropriate threshold. For example:

    "CHI", "TWC", 47, 49, "lt="

    TWC is forecasting that it will be 47 degrees. But we want to see what
    the 'odds' are that the actual temperature will be less than or equal
    to 49. So we see how often TWC has made an error of less than 2. In our
    case, in the past if it said 47, but was actally 45, this is an error of -2,
    so it would be counted"""
    
    if isinstance(threshold, type(int())):
        error = threshold - forecast
    elif isinstance(threshold, type(tuple())):
        error = (threshold[0] - forecast, threshold[1] - forecast)
    
    k = city_platform(df, city, platform)
    samples = len(k)

    
    k = trim_errors(k, error, operator)
    
    errors = len(k)
    
    return errors, samples

def errors_by_city(df_f, df, city, threshold, operator):
    """For each city in a forecast DataFrame, get the odds
    Returns a dict"""
    
    df_f = df_f[df_f["CITY"] == city].copy()
    
    errors_dict = dict()
    
    for row in df_f.itertuples():
        
        # get each platform and forecast
        t = errors_by_platform(df, city, row[5], row[6], threshold, operator)
        errors_dict[row[5]] = t
    return errors_dict

def odds_by_city(df_f, df, city, threshold, operator):
    """Converts the dict of odds generated by errors_by_city
    into a dataframe and then also does a total value"""
    
    
    errors = errors_by_city(df_f, df, city, threshold, operator)
    df_e = pd.DataFrame.from_dict(errors, orient='index', columns=["errors", "samples"])
    
    to_add = {"errors":df_e["errors"].sum(), "samples":df_e["samples"].sum()}
    df_e = df_e.append(pd.Series(to_add, name="Total"), ignore_index=False)
    
    df_e["probability"] = df_e["errors"] / df_e["samples"]
    
    return df_e

def odds(forecast_list, handles):
    """Wrapper function that takes a forecast for the next day
    and the thresholds for prediction and then calculates the odds"""
    
    odds_dict = dict()

    df = db.forecasts_and_observations()
    df = process_forecasts_and_observations(df)
    df_f = list_to_dataframe(forecast_list)
    
    for city in handles:
        for operator in handles[city]:
            if operator == "bw":
                for pair in handles[city][operator]:
                    
                    k = odds_by_city(df_f, df, city, pair, operator)
                    
                    key = key_gen(city, operator, pair)
                    
                    odds_dict[key] = k
            else:
                threshold = handles[city][operator]
                k = odds_by_city(df_f, df, city, threshold, operator)
                key = key_gen(city, operator, threshold)
                odds_dict[key] = k
                    
    return odds_dict
